# 一次线上生产告警探究-性能优化
> 将现有的实时查询改成离线查询。因为实时查询导致数据库扛不住，所以改成hive表离线查询。坦白点，就是换个数据源，其他的不变。
## 上线验证
应用发布线上之后。点击测试几次（后面查看我点了40多次）。然后突然收到一波告警，引起大家注意，大家就来咨询我是啥情况。监控大盘显示，CPU空闲率到了0，JVM GC次数明显增多。然后第一时间关闭线上操作入口。

回想一下，自己就修改了数据源。其他的啥代码都没有改，能有啥问题呢？

## 分析原因
### CPU耗时分析
分析性能火焰图看到下面耗时太长

![](https://cdn.jsdelivr.net/gh/filess/img8@main/2021/05/16/1621169555954-14e28c95-155e-4fc1-aeb2-51b6e80499fe.png)

![](https://cdn.jsdelivr.net/gh/filess/img14@main/2021/05/16/1621169616284-2ccef977-863c-4dfe-af30-1c776257bb74.png)


![](https://cdn.jsdelivr.net/gh/filess/img12@main/2021/05/16/1621169646880-eb3f84c7-c6aa-4d43-a4f8-6951efbd5ead.png)


因此建议数据库存储时间戳比较妥。这样时间处理相当于long类型数据。就不需要转化了。
解决方案
在SQL中使用
`unix_timestamp(addtime)`
把date的string 格式转成long，然后使用long生成date
```
long modTimestamp = Long.parseLong((String) ls.get(8));
operationTaskDTO.setModTime(new Date(modTimestamp));
```

![](https://cdn.jsdelivr.net/gh/filess/img9@main/2021/05/16/1621173723036-77ddc78e-e433-4fbe-8001-1cb8b230aa36.png)

上面时间转换顶多是耗CPU操作，但是不至于GC增加

![](https://cdn.jsdelivr.net/gh/filess/img12@main/2021/05/16/1621173755551-b6af6954-d234-43b3-8cac-7b66e4804c2e.png)

下面这个List大概有几十万条。

#### 再次分析

![](https://cdn.jsdelivr.net/gh/filess/img4@main/2021/05/16/1621173945878-a8d9b511-fad0-4619-904f-ec5d3a36c8a5.png)

![](https://cdn.jsdelivr.net/gh/filess/img15@main/2021/05/16/1621174043913-8bab141c-fc97-463d-8613-eb0bb4d8448d.png)

![](https://cdn.jsdelivr.net/gh/filess/img17@main/2021/05/16/1621174061299-3a604cde-01aa-4273-b017-d0db6ccee1c5.png)

从List的contains()源代码可以得知这个底层实现方式

![](https://cdn.jsdelivr.net/gh/filess/img8@main/2021/05/16/1621174213829-417be5bd-a584-4e90-bb7a-728099f12066.png)

上面这个确实很坑爹！！！List来判断contains，循环遍历比较。不去利用Set的hashcode和equals。将List改成HashSet

![](https://cdn.jsdelivr.net/gh/filess/img16@main/2021/05/16/1621174300566-6aa408f0-e53c-41c4-b0b3-e278faecf3b8.png)

### full GC优化
![](https://cdn.jsdelivr.net/gh/filess/img11@main/2021/05/16/1621173814844-6e0ad05e-2fbb-4deb-91c7-a2f1a2d3e1e3.png)

下图中添加了Set,避免ArrayList.contains，继续发现新建的两个ArrayList也不是很妥，只是为了统计数量，没有必要新建一个ArrayList。

![](https://cdn.jsdelivr.net/gh/filess/img8@main/2021/05/16/1621174430534-26621152-76c6-4f87-8150-1764da3937bd.png)

进一步优化，去掉两个非必要的ArrayList，这也是导致GC的诱因，大数组！！！


![](https://cdn.jsdelivr.net/gh/filess/img2@main/2021/05/16/1621174497693-cc8958c3-be55-47cf-aebf-f7a852ec3749.png)


## 最终测试结果

### CPU空闲率

![](https://cdn.jsdelivr.net/gh/filess/img17@main/2021/05/16/1621174534485-46cdc3a3-05c5-4416-9bf5-d97967824f16.png)

### GC

![](https://cdn.jsdelivr.net/gh/filess/img0@main/2021/05/16/1621174542186-cff4a5e7-85b2-4922-bdf6-5a62fb571dc9.png)

### 火焰图

![](https://cdn.jsdelivr.net/gh/filess/img1@main/2021/05/16/1621174549187-b90491c4-28c2-4d78-875c-6aa07747dc85.png)

## 总结
* 合理使用Set和List
* 看场景使用ArrayList和LinkedList。
* 需要了解基本的数据结构底层实现原理，以及常用方法的实现方式。
* 了解full GC的诱因。

## 参考

一旦网卡利用率达到100%就会成为性能瓶颈

https://www.cnblogs.com/hama1993/p/10580581.html

https://www.infoq.cn/article/2016/02/utilisation-wait-latency

https://www.jianshu.com/p/dde394a143e5
