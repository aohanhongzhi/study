程序死锁分析
============

这种情况在运用多线程编程的时候比较容易出现。

死锁的四个条件

1. 独占性
2. 排他性
3.

## 样例代码

```java
package hxy.dream.app.controller;

import hxy.dream.entity.vo.BaseResponseVO;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.TimeUnit;

/**
 * @author eric
 * @program multi-gradle
 * @description 死锁代码
 * @date 2022/1/25
 */
@RestController
@RequestMapping("/deadlock")
public class DeadLockController {
    Object lock = new Object();
    Object lock2 = new Object();

    @RequestMapping("test")
    public BaseResponseVO dead() {
        new Thread(() -> {
            synchronized (lock) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("thread1 over");
                }
            }
        }).start();

        new Thread(() -> {
            synchronized (lock2) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock) {
                    System.out.println("thread2 over");
                }
            }
        }).start();
        return BaseResponseVO.success("死锁测试");
    }
}

```

## 问题定位

死锁的时候，代码的CPU一般不会很高。
死锁的代码很好找出来，先找到Java的线程。

`top`或者`ps -ef |grep java`

然后直接使用jstack pid打印出当前进程内线程的运行状态信息。

![](assets/20220125_191916_image.png)

最下面就会提示死锁的情况！

![](assets/20220125_192305_image.png)
