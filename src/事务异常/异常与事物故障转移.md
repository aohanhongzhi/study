异常与事务以及故障转移和灰度发布
===



本文从微观到宏观展示异常在系统的作用。



# 当不满足条件的时候，应该建议直接返回，还是抛出异常？

例如为null的时候？登录密码校验不一致的时候？

这个问题一直困扰着我，因为异常的处理会消耗虚拟机的性能。但是在SpringSecurity等源码中发现，在密码校验失败的时候还是抛出异常来处理的。这就让人很疑惑，不知道出了意外的时候咋处理比较妥，是应该try住吞了，还是任由他去。

带着我多年的疑惑。下面就先从基本的知识点来一步一步从微观到宏观看看每一步怎么实现比较合理。

## 错误:

java.lang.Error 一般java虚拟机处理不了，程序不会从错误中恢复。

## 异常:

**运行时异常**  RuntimeException

**检查性异常** 打开一个不存在的文件  IOException

![](throw.jpg)



### 单个处理

异常处理的原则，要么就处理，要么就抛出。不要处理和抛出同时弄了，这里的处理是像logger.error()记录。很多情况下我们可能会觉得出现异常的时候也只能logger打个记录，并不能做什么其他的处理。这也是本文的重点，告诉你处理logger下，还可以进一步处理，实现故障转移。一般单个处理比较适合下面情况。

例如：

```java
    public final void afterPropertiesSet() throws IOException {
        if (this.singleton) {
            this.singletonInstance = this.createProperties();
        }
    }
```
> 单个处理适用于不得不处理的异常，例如方法后面标记了异常。

那么在调用这个方法的时候，要么就try住，要么就继续抛出。

第一种：再次抛出

```java
    @Bean
    public Properties quartzProperties() throws IOException {
    
        propertiesFactoryBean.afterPropertiesSet();

        return propertiesFactoryBean.getObject();
    }
```

第二种：直接处理了

```java
    @Bean
    public Properties quartzProperties() {
        PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
        propertiesFactoryBean.setLocation(new ClassPathResource("/quartz.properties"));
        
        Properties object = null;
        try {
            propertiesFactoryBean.afterPropertiesSet();
            object = propertiesFactoryBean.getObject();
        } catch (IOException e) {
            log.error("\n====>{}", e.getMessage(), e);
        }
        return object;
    }
```





### 批量处理

全局异常捕获

> 没有主动在方法后面标记抛出异常的情况。

例如，下面的insert并没有标记异常的抛出，但是当数据库发生意外的时候，还是会主动抛出异常。所以try了一下。

```java
try{
    userService.register(userModel);
}catch(RuntimeException e){
    logger.error("\n====>保存失败")
}
```

上面看出来处理确实比较稳妥，但是每个可能抛出异常的服务都这么弄，确实很容易造成所有的方法都需要try下。看起来不是优雅，所以建议使用全局异常捕获。

全局异常捕获目的就是为了捕获全局的异常，然后处理，最后返回给前端。

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.messaging.handler.annotation.support.MethodArgumentNotValidException;
import org.springframework.validation.BindException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import javax.servlet.http.HttpServletRequest;
import javax.validation.ConstraintViolationException;
import javax.validation.ValidationException;

/**
 * Description:全局异常处理，采用@Controller + @ExceptionHandler解决
 * <br>自定义异常处理类
 *
 * @author eric
 */
@ControllerAdvice
@Slf4j
@ResponseBody
public class GlobalExceptionHandler {

    /**
     * 业务异常捕获
     *
     * @param request
     * @param e
     * @param <T>
     * @return
     */
    @ExceptionHandler(BaseException.class)
    public <T> BaseResponse<?> baseExcepitonHandler(HttpServletRequest request, BaseException e) {
        log.error("\n====>{} Exception", request.getRequestURI(), e.getMessage(), e);
        return BaseResponse.error(e.getMessage());
    }

    /**
     * ValidationException
     */
    @ExceptionHandler(ValidationException.class)
    public <T> BaseResponse<?> handleValidationException(ValidationException e) {
        log.warn(e.getMessage(), e);
        return BaseResponse.error("校验出错啦！", e.getMessage());
    }

    /**
     * 参数校验异常捕获 包括各种自定义的参数异常
     *
     * @param request
     * @param e
     * @param <T>fsFileId
     * @return
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(ConstraintViolationException.class)
    public <T> BaseResponse<?> constraintViolationExceptionHandler(HttpServletRequest request, ConstraintViolationException e) {
        log.warn("\n====>{} Exception Message: {}", request.getRequestURI(), e.getMessage(), e);
        return BaseResponse.error("参数错误", e.getMessage());
    }


    /**
     * 方法参数校验
     * https://blog.csdn.net/chengliqu4475/article/details/100834090
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public <T> BaseResponse<?> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        log.warn(e.getMessage(), e);
        return BaseResponse.error("参数检验出错啦！", e.getBindingResult().getFieldError().getDefaultMessage());
    }


    /**
     * 处理400参数错误
     *
     * @param e
     * @return
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public BaseResponse handleHttpMessageNotReadableException(HttpMessageNotReadableException e) {
        log.warn("参数解析失败{}", e.getMessage(), e);
        return BaseResponse.badrequest("参数解析失败", e.getMessage());
    }

    /**
     * 405错误方法不支持
     *
     * @param e
     * @return
     */
    @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public BaseResponse handleHttpRequestMethodNotSupportedException(HttpServletRequest request, HttpRequestMethodNotSupportedException e) {
        log.warn("\n====>[{}]不支持当前[{}]请求方法,应该是[{},{}]", request.getRequestURI(), e.getMethod(), e.getSupportedHttpMethods(), e.getSupportedMethods(), e);
        return BaseResponse.badrequest("请求方法不支持", e.getMessage());
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(BindException.class)
    public BaseResponse bindException(BindException e) {
        log.warn("\n====>请求参数错误:{}", e.getMessage(), e);
        return BaseResponse.badrequest(e.getBindingResult().getFieldError().getDefaultMessage());
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MissingServletRequestParameterException.class)
    public BaseResponse MissingServletRequestParameterException(MissingServletRequestParameterException e) {
        log.warn("\n====>请求参数错误{}", e.getMessage(), e);
        return BaseResponse.badrequest("请求参数错误", e.getMessage());
    }

    @ExceptionHandler(DuplicateKeyException.class)
    public BaseResponse handleDuplicateKeyException(DuplicateKeyException e) {
        log.warn(e.getMessage(), e);
        return BaseResponse.badrequest("请求参数错误", e.getMessage());

    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(NullPointerException.class)
    public <T> BaseResponse<?> nullPointerExcepitonHandler(HttpServletRequest request, NullPointerException e) {
        log.error("\n====>{} NULL POINT Exception", request.getRequestURI(), e.getMessage(), e);
        return BaseResponse.error("biu，踩雷啦！", e.getMessage());
    }

    /**
     * 这个应该放在最下面比较好，最后加载
     * 处理未定义的其他异常信息
     * 参数为空等
     *
     * @param request
     * @param exception
     * @return
     */
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(value = Exception.class)
    public BaseResponse exceptionHandler(HttpServletRequest request, Exception exception) {
        log.error("\n====>{} Exception Message: {}", request.getRequestURI(), exception.getMessage(), exception);
        return BaseResponse.error("服务器异常", exception.getMessage());
    }

}

```



注意注意标记好该请求的返回状态。合理标记 @ResponseStatus注解中的HttpStatus，后面的SpringRetry就会依据这个状态来做故障转移。

> 合理的设置logger级别，配合logback可以做到邮件报警，及时邮件报告线上错误。

# 事务的原子性在日常编程的时候有哪些体现？

上面讲了异常处理方式，接下讲异常与事务的关系。先来了解下事务。

数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

数据库的事务有四大特性，即原子性、一致性、隔离性、持久性。其中原子性与业务息息相关。不规范的编码会导致事务的原子性无法正确运用。而其他的三个特性基本上由数据库自己决定，与编码质量不是很相关。

原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。

举个栗子：银行账户，一个人给另一个人转账，即意味着一个人的余额增加，一个人的余额减少。一个加，一个减。这两个操作无法同时完成，一般来说应该是先减少，再另一个人增加。万一减少成功，增加的时候网络异常，到导致没有增加成功，那么就会造成整体的金额数量减少，也就凭空蒸发了。很显然这不是很符合会计学的有借必有贷,借贷必相等的基本原则。那么这时候就应该合理编码，好好利用下事务的原子性。



```java
@Transactional(rollbackFor=RuntimeException.class)
public transfer(People borrower,People payee, BigDecimal value){
    // 从一个账户里减少
    boolean result = transferService.sub(borrower,value);
    // 给另一个账户增加
    boolean result =  transferService.add(payee,value);
    if(!result){
        // 添加失败就直接抛出异常
        throw new RuntimeException("收款人增加金额失败"+value);
    }
}
```



Spring 事务回滚机制是这样的：当所拦截的方法有指定`异常抛出`，事务才会自动进行回滚！也就是说事务需要异常来配合才能触发。
```java
1 @Transactional(rollbackFor=Exception.class) //指定回滚,遇到异常Exception时回滚
2 public void methodName() {
3 　　　throw new Exception("注释");
4 }
```

如果没有异常的抛出，那么事务就不会回滚。所以吞了异常并不是一个好的处理方式，会导致事务失效。

> https://www.cnblogs.com/caoyc/p/5632963.html

# http的状态与Java返回的code该怎么使用？

## code

这个code基本上与各个业务定义相关，可以所以制定规则。但是最好通用比较好。

![](code.png)
> 针对业务的
## status

status code是http协议制定的，所以基本上全球通用。后面讲的SpringRetry实现的故障转移就是依据这个status。

![](200.png)
> 针对http协议的






### 故障转移

故障转移，当gateway发现服务提供者返回状态为预期异常状态的时候就可以重新发起请求。



![](故障转移.png)





### 灰度发布

访问不存在的接口的时候必然返回的就是404，那么必然就会触发网关的重试机制。发布的时候注意部分发布即可，不要同时更新所有应用。









![](故障转移2.png)



> https://cnblogs.com/nulige/articles/10929182.html

## 如何实现网关的故障转移？

在Netflix-ZUUL里面添加下面依赖，然后yaml中配置下相关信息即可。

```xml
       <!--        500等异常状态的的重试-->
        <dependency>
            <groupId>org.springframework.retry</groupId>
            <artifactId>spring-retry</artifactId>
        </dependency>
```

```yaml
ribbon: #设置ribbon的超时时间小于zuul的超时时间
  ReadTimeout: 100000
  ConnectTimeout: 100000
  maxAutoRetries: 1
  maxAutoRetriesNextServer: 3
  OkToRetryOnAllOperations: true  #默认为false,则只允许GET请求被重试
  retryableStatusCodes: 500,502,404,400 # 500服务器内部错误，502网关超时，404服务没有找到，400客户端请求错误，例如参数错误

```

> 整体需要配合Eureka等一套完整的微服务体系。

# 总结

程序编码的时候需要合理的设计异常机制，对于不满足条件的情况应当及时抛出异常，事务回滚，保证业务的数据合理性。然后再通过全局异常捕获进一步针对性处理，注意标记好请求的http status。然后再由SpringZuul的SpringRetry去实现故障转移。