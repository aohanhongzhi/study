什么叫异步编程？ NIO的非阻塞又是什么意思？
===

在我刚接触NIO的时候，听到了一个新的概念：非阻塞，一开始我对他的理解真的是非常的浅薄，甚至不知道歪曲到哪里去了，我一度认为 非阻塞 就是用多线程 并发执行，后来才发现我错了。


我们通常所说的异步编程 ，虽然要用到线程，~~但不是指多线程~~。举个很简单的例子，nodejs的eventloop 就不是多线程的，java的线程池 也不是， 他们都只有几个线程在那 消费队列里的任务而已，你丢进去的任务再多，都不会增加线程的数量。

异步编程一般指的是 依赖回调，nodejs里面这种东西满天都是，这也是他对外宣传的一个特点，至于NIO调用业务层需要多线程，这叫并发执行，线程与线程之间并不需要互相等待，都是并行的相互独立的业务线，每条线程内部都是同步的。


NIO的非阻塞 到底是什么意思？  举个很简单的例子，如果客户端发起一个TCP连接到服务端，BIO的做法是开启一个线程，然后读取客户端发来的数据，这么做会遇到一些问题，

- 如果客户端发起连接以后不发数据，
- 或者 因为网络原因，服务端接收数据的时候断断续续的，
- 又或者 客户端就是故意 分片发送， 

这样会导致这个线程陷入阻塞，

- 当不发数据的时候服务端读不到数据所以线程阻塞在这，
- 当断断续续的时候，这个断断续续的间隔会阻塞在这得不到充分利用，

没办法最大化的利用服务器资源，所以才出现了NIO，NIO的精髓在于Selector，连接进来只会注册到Selector，当服务端收到数据了会触发一个read事件，当事件被触发以后才会读取数据，而且只读已经收到的这部分，读完就抛到协议层去处理，协议层负责将读出来的这一段段数据进行拼接，解析。当拼接到一个完整报文的时候，就会丢给业务层去处理业务逻辑， 

说白了就是：连接进来的时候就一边等着去，有数据我才处理，收到多少数据就处理多少数据，处理完拉倒，不会一直停在这等客户端的。属于一种最大化利用服务器资源的手段，并不是什么黑科技。


NIO解决的只是这个问题而已，所以他叫非阻塞，**解决的是网络层的阻塞** ，不是 **业务层的阻塞** 。业务层跟什么IO都没关系，不管用什么IO，业务层都是多线程并发执行的。

本文来源：https://mp.weixin.qq.com/s/F-ZrLknnKi_Y3nxszpjDJQ